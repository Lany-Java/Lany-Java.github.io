<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XML文件中的xmlns、xmlns:xis、xsi、schemaLocation、dtd</title>
    <url>/2019/11/22/XML%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84xmlns%E3%80%81xsischemaLocation%E3%80%81dtd/</url>
    <content><![CDATA[<p>最近在学习的时候经常遇到关于XML的问题，我对其中的xmlns、xmlns-xsi、xsi、schemaLocation等知识点却不是很了解</p>
<p>这一篇文章我就用来记录一下我对于这方面的学习</p>
<h2 id="xmlns"><a href="#xmlns" class="headerlink" title="xmlns"></a>xmlns</h2><h3 id="xmlns产生原因"><a href="#xmlns产生原因" class="headerlink" title="xmlns产生原因"></a>xmlns产生原因</h3><p>我们先来看以下的两个XML文档</p>
<p>表格</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;tr&gt;</span><br><span class="line">		&lt;td&gt;Apples&lt;/td&gt;</span><br><span class="line">		&lt;td&gt;Bananas&lt;/td&gt;</span><br><span class="line">	&lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>桌子</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">	&lt;name&gt;AfricanCoffeeTable&lt;/name&gt;</span><br><span class="line">	&lt;width&gt;80&lt;/width&gt;</span><br><span class="line">	&lt;length&gt;120&lt;/length&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>这两个XML文档都是使用的标签，那我们假设当这两个文档被一起使用，由于都包含有table标签的缘故，我们无法知晓使用的是哪个table，就会发生命名冲突，XML解析器无法确定如何解决这样的冲突，于是为了解决以上带来的问题，我们就诞生了xmlns<p></p><h3 id="xmlns的使用"><a href="#xmlns的使用" class="headerlink" title="xmlns的使用"></a>xmlns的使用</h3><a id="more"></a><p>xmlns的全称是XML Namespaces，是XML命名空间，作用就是赋予命名空间一个唯一的名称</p><p>使用语法：xmlns:namespace-prefix=”namespaceURI”</p><p>namespace-prefix ：自定义命名空间前缀</p><p>namespaceURI ：这个前缀对应的XML Namespace的定义</p><p><strong>注意：用于标示命名空间的地址不会被解析器用于查找信息。其惟一的作用是赋予命名空间一个惟一的名称。不过，很多公司常常会作为指针来使用命名空间指向实际存在的网页，这个网页包含关于命名空间的信息</strong></p><p>xmlns如果不在后面加上命名空间前缀，那么此命名空间就是该XML文档的默认命名空间</p><h2 id="xis-schemaLocation"><a href="#xis-schemaLocation" class="headerlink" title="xis:schemaLocation"></a>xis:schemaLocation</h2><p>xsi:schemaLocation属性其实是Namespace为<a href="http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性</a></p><p>因为我们一开始声明了</p><div class="note default"><p>xmlns:xsi=”<a href="http://www.w3.org/2001/XMLSchema-instance&quot;" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance"</a></p></div><p>而这个是遵从w3规范，是固定写法</p><p>我们通过xsi:schemaLocation来将Namespace和其XSD(Xml Schema Definition)文档进行对象，它由多个URL引用对组成，两个URL之间以空白符(空格或者换行都行)分隔，第一个URL是Namespace的值，第二个URL是Schema文档的位置</p><h2 id="dtd：XML中的文档声明类型：dtd"><a href="#dtd：XML中的文档声明类型：dtd" class="headerlink" title="dtd：XML中的文档声明类型：dtd"></a>dtd：XML中的文档声明类型：dtd</h2><p>dtd是一种对XML的约束，就是定义了之后，该XML文档必须按照我的约束条件来写</p><p>而dtd又分了内部dtd和外部dtd</p><p>内部dtd使用使用系统标识符(System)</p><p>外部dtd使用公共标识符(Public)</p><table>

















</table></p><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>XML</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的二维数组</title>
    <url>/2019/10/30/Java%E4%B8%AD%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="Java中的二维数组"><a href="#Java中的二维数组" class="headerlink" title="Java中的二维数组"></a>Java中的二维数组</h2><p>在Java的二维数组中，静态引用的方式和C语言是不一样的，具体是怎样的，我们接着往下看</p>
<a id="more"></a>
<p>二维数组的初始化分为动态初始化和静态初始化</p>
<ol>
<li>动态初始化</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int [][]arry = new int[2][3];</span><br><span class="line">arry[0][1] = 1;</span><br><span class="line">arry[0][2] = 2;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></tbody></table></figure>

<p>动态初始化大家都用的很熟悉，这里就不在多加赘述了</p>
<ol start="2">
<li>静态初始化</li>
</ol>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int [][]arry = {</span><br><span class="line">	{1,2},</span><br><span class="line">	{1,2,3},</span><br><span class="line">	{1,2,3,4}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>Java中我们<strong>将二维数组看做是数组的数组，数组的空间分配是不连续的</strong>，这一点与C语言是大不相同的，正是因为这一特点，所以在Java中我们<strong>不要求二维数组每一维的大小相同</strong></p>
<p>所以在以上的arry二维数组中，第一行只有1和2两个值，第三位和第四位是不存在的，如果我们去遍历这个二维数组不能按以下方式去遍历：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) {</span><br><span class="line">	for (int j = 0; j &lt; 4; j++) {</span><br><span class="line">		System.out.println(arry[i][j]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果按照这个方式去遍历，则系统会报数组下标越界的错误</p>
<p>正确的遍历方式:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; 3; i++) {</span><br><span class="line">	for (int j = 0; j &lt; arry[i].length; j++) {</span><br><span class="line">		System.out.println(arry[i][j]);</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以最后我们要谨记：<strong>在Java中我们不要求每一维的大小相同，所以在遍历的时候，我们要注意内循环的遍历次数是通过获取单行的长度<span class="label default">arry[i].length</span>来获得的</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>包及访问控制权限</title>
    <url>/2019/10/30/%E5%8C%85%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是在使用多个类或接口时，为了避免名称重复而采用的一种措施。如果要使用直接在程序中加入package即可</p>
<p>两个类如果是存放在不同的包中，则在使用类的时候就必须通过import进行导入</p>
<p>注意：</p>
<ol>
<li><p><strong>如果我们在一个程序中导入了两个包的同名类，在使用的时候必须明确的写出完整的”包.类名称”，如果我们不这样写那么就会如下：</strong><br><img src="1.png" alt=""><br>在这个例子中com.lany.a和com.lany.b都含有C这个类，但是我用的是”*“导入，这就导致无法分别是使用的哪一个包中的C，会导致程序报错</p>
<a id="more"></a></li>
<li><p><strong>如果我们在使用包名.子包名.类名的全称，那么就不需要使用import导入</strong></p>
</li>
<li><p><strong>关于分别导入和”*“哪种导入方式的性能更高</strong></p>
 <div class="note default"><p>上面程序的两种导入方式：<br>    1. import com.lany.a.C<br>    2. import com.lany.a.*</p>
<p>我们凭感觉好像第一种是要比第二种的效率高</p>
<p>但其实这两种方式本身不再存在任何的性能问题，因为使用”*“也是自动加载所需的类，而不需要的类根本是不会被加载进来的</p></div>

</li>
</ol>
<p>Java新特性–静态导入</p>
<p>在JDK1.5之后提供了静态导入功能，如果一个累的方法全部是使用static声明的静态方法，则在导入的时候就可以直接使用“import static”的方式导入</p>
<p>使用了静态导入，一个类的所有静态方法就可以治直接通过<span class="label default">静态方法名()</span>进行调用，而不需要使用<span class="label default">类名.静态方法名()</span>进行调用</p>
<h2 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h2><p>在Java中一共有4种访问权限修饰符：private、default、protected和public</p>
<p><img src="2.png" alt=""></p>
<p>访问权限从小到大：</p>
<ol>
<li><p>private访问权限</p>
 <div class="note default"><p><strong>本类</strong>可以访问，其他类不行</p></div>
</li>
<li><p>default访问权限</p>
 <div class="note default"><p><strong>本包中的类</strong>可以访问，其他包中的类无法访问</p></div>
</li>
<li><p>protected访问权限</p>
 <div class="note default"><p><strong>本包及其他包子类</strong>可以访问</p></div>
</li>
<li><p>public访问权限</p>
 <div class="note default"><p><strong>所有类</strong>都可以访问</p></div>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>权限修饰符</tag>
        <tag>包</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类与接口</title>
    <url>/2019/10/28/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p><strong>抽象类是对根源的抽象</strong></p>
<p>抽象类的设计目的，是<strong>代码复用</strong>。当不同的类具有某些相同的行为(记为行为集合A)，且其中一部分行为的实现方式一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类中实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。正是因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用到A-B时，无法执行）。</p>
<a id="more"></a>
<p>抽象类的定义以及使用规则：</p>
<ul>
<li>包含一个抽象方法的类必须是抽象类</li>
<li>抽象类和抽象方法都要使用abstract关键字声明</li>
<li>抽象方法只能声明而不能实现</li>
<li>抽象类如果要实例化对象，必须被子类继承，子类(如果不是抽象类)必须覆写抽象类中的全部抽象方法</li>
</ul>
<p>其实<strong>抽象类</strong>较之于<strong>普通类</strong>只有以下几点区别：</p>
<div class="note default"><p>从类的层面上来讲：<br>    1. 抽象类不能使用final声明，普通类可以使用<br>    2. 抽象类使用abstract修饰，普通不能使用<br>    3. 抽象类不能直接实例化<br>从方法的层面上来讲：<br>    1. 抽象类包含抽象方法，普通类不包含<br>从属性的层面来讲，二则并无区别</p></div>

<p>从类的层面来讲我们都很容易理解，但是抽象方法和普通的方法有哪些区别呢？</p>
<p>抽象方法：</p>
<div class="note default"><p>抽象方法是没有方法体，使用abstract修饰的方法，在其后直接加上 ; 而不是花括号</p></div>

<p>抽象方法较之于普通方法的不同：</p>
<div class="note default"><ol>
<li>不能使用final修饰抽象方法，因为抽象方法要被子类所覆写的，如果声明为final，就无法覆写了</li>
<li>修饰符<strong>只能使用protected和public</strong>，如果使用private那么其他类无法访问，也就无法覆写，如果使用default那么其他包的子类无法访问，同样也无法覆写</li>
<li>必须被子类(非抽象类)覆写</li>
<li>非抽象类子类必须覆写全部的抽象方法</li>
</ol></div>

<p>当然，从思想上，抽象类和普通类最大的区别在于强制</p>
<div class="note default"><p>如果是普通类，那么子类可以根据自己的需要选择性的进行某些父类方法的覆写，所以对于普通类来说，无法对子类覆写的方法进行限制</p>
<p>如果是抽象类，它可以强制性的要求子类覆写父类所有的抽象方法</p>
<p>正因为二者对于方法覆写的强制性不同，所以在开发中，不建议让子类继承普通类，而只建议子类继承抽象类</p></div>


<p>除了以上的一些不同，抽象类和普通并没有什么不同，成员变量、成员方法和构造方法的访问方式和普通类一样</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>接口是对动作的抽象</strong></p>
<p>接口的设计目的，是对<strong>类的行为进行约束</strong>（更准确的说是一种“有”约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制。对“接口为何是约束”的理解，我觉得配合泛型食用效果更佳。</p>
<p>接口的成员：</p>
<div class="note default"><ol>
<li>全局常量</li>
<li>抽象方法：修饰符只能是public,而且默认也是public</li>
</ol></div>

<p>接口、抽象类之间的继承关系</p>
<div class="note primary"><p>接口不允许继承抽象类<br>接口可以继承多个接口</p>
<p>抽象类可以实现多个接口<br>抽象类可以继承抽象类</p></div>

<p>接口的定义加强：<br>    在JDK1.8以前，接口是由抽象方法和全局常量组成，但是这种设计在JDK1.8之后发生了改变，即从JDK1.8开始可以在接口中定义普通方法(使用default声明)与静态方法(使用static声明)</p>
<h2 id="抽象类与接口之间的关系"><a href="#抽象类与接口之间的关系" class="headerlink" title="抽象类与接口之间的关系"></a>抽象类与接口之间的关系</h2><table>
<thead>
<tr>
<th align="right">序号</th>
<th align="center">区别点</th>
<th align="center">抽象类</th>
<th align="center">接口</th>
</tr>
</thead>
<tbody><tr>
<td align="right">1</td>
<td align="center">定义</td>
<td align="center">包含抽象方法的类</td>
<td align="center">抽象方法和全局常量的集合</td>
</tr>
<tr>
<td align="right">2</td>
<td align="center">组成</td>
<td align="center">构造方法、抽象方法、普通方法、常量、变量</td>
<td align="center">常量、抽象方法</td>
</tr>
<tr>
<td align="right">3</td>
<td align="center">使用</td>
<td align="center">子类继承抽象类(extends)</td>
<td align="center">子类实现接口(implements)</td>
</tr>
<tr>
<td align="right">4</td>
<td align="center">关系</td>
<td align="center">抽象类可以实现多个接口</td>
<td align="center">接口不能继承抽象类、但是允许继承多个接口</td>
</tr>
<tr>
<td align="right">5</td>
<td align="center">常见设计模式</td>
<td align="center">模板设计</td>
<td align="center">工厂设计、代理设计</td>
</tr>
<tr>
<td align="right">6</td>
<td align="center">对象</td>
<td align="center">都通过对象的多态性产生实例化对象</td>
<td align="center">都通过对象的多态性产生实例化对象</td>
</tr>
<tr>
<td align="right">7</td>
<td align="center">局限</td>
<td align="center">抽象类有单继承的局限</td>
<td align="center">接口没有单继承的局限</td>
</tr>
<tr>
<td align="right">8</td>
<td align="center">实际</td>
<td align="center">作为一个模板</td>
<td align="center">是作为一个标准或者表示一种能力</td>
</tr>
<tr>
<td align="right">9</td>
<td align="center">选择</td>
<td align="center">如果抽象类和接口都可以使用的话，优先使用接口，避免单继承的局限</td>
<td align="center">如果抽象类和接口都可以使用的话，优先使用接口，避免单继承的局限</td>
</tr>
<tr>
<td align="right">10</td>
<td align="center">特殊</td>
<td align="center">一个抽象类可以包含多个接口</td>
<td align="center">一个接口可以包含多个抽象类</td>
</tr>
</tbody></table>
<p>在类的设计中，一定铭记以下原则：</p>
<div class="note default"><p>一个类不要去继承一个已经实现好的类，要么继承抽象类，要么实现接口，如果接口和抽象类都可以使用的话，那么优先使用接口，避免单继承的局限</p></div><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA中使用Debug功能</title>
    <url>/2019/10/28/IDEA%E4%B8%AD%E4%BD%BF%E7%94%A8Debug%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<h2 id="基本用法和快捷键"><a href="#基本用法和快捷键" class="headerlink" title="基本用法和快捷键"></a>基本用法和快捷键</h2><p>Debug调试的功能主要对应着两组按钮</p>
<ol>
<li><p>首先是第一组，一共八个按钮，从左至右一次如下<br> <img src="first.png" alt=""></p>
 <a id="more"></a>
<ul>
<li>show Execution Point(Alt+F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</li>
<li>Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li>
<li>Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。</li>
<li>Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</li>
<li>Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</li>
<li>Drop Frame (默认无)：回退断点，后面章节详细说明。</li>
<li>Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</li>
<li>Evaluate Expression (Alt + F8)：计算表达式</li>
</ul>
</li>
<li><p>第二组按钮</p>
<p> <img src="second.png" alt=""></p>
<ul>
<li>Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</li>
<li>Resume Program (F9)：恢复程序，比如，你在第20行和25行有两个断点，当前运行至第20行，按F9，则运行到下一个断点(即第25行)，再按F9，则运行完整个流程，因为后面已经没有断点了</li>
<li>Pause Program：暂停程序，启用Debug。目前没发现具体用法。</li>
<li>Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。有时候你会发现关闭服务再启动时，报端口被占用，这是因为没完全关闭服务的原因，你就需要查杀所有JVM进程了</li>
<li>View Breakpoints (Ctrl + Shift + F8)：查看所有断点</li>
<li>Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled</li>
</ul>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内部类</title>
    <url>/2019/10/26/Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="什么是内部类？"><a href="#什么是内部类？" class="headerlink" title="什么是内部类？"></a>什么是内部类？</h1><p>来自《Java核心技术 卷一》之中的定义：</p>
<div class="note default"><p>内部类是定义在另一个类中的类</p></div>

<h1 id="为什么我们要使用内部类？"><a href="#为什么我们要使用内部类？" class="headerlink" title="为什么我们要使用内部类？"></a>为什么我们要使用内部类？</h1><p>在某些情况下使用内部类会有很好的效果，主要好处有如下几点：<a id="more"></a></p>
<div class="note default"><ol>
<li>内部类方法可以访问该类定义所在作用域中的数据，<strong>包括私有数据</strong></li>
<li>内部类可以对同一包中的其他类隐藏起来</li>
<li>内部类可以解决 java 单继承的缺陷，从而实现多继承</li>
<li>当想要定义一个回调函数并且不想编写大量代码时，使用匿名内部类比较便捷</li>
</ol></div>

<h2 id="1-内部类方法可以访问该类定义所在作用域中的数据"><a href="#1-内部类方法可以访问该类定义所在作用域中的数据" class="headerlink" title="1.内部类方法可以访问该类定义所在作用域中的数据"></a>1.内部类方法可以访问该类定义所在作用域中的数据</h2><p>我们下面来看一个实例：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class TalkingClock {</span><br><span class="line">    private int interval;   //时间间隔</span><br><span class="line">    private boolean beep;	//标志位</span><br><span class="line"></span><br><span class="line">    public TalkingClock(int interval,boolean beep){</span><br><span class="line">		...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void start(){</span><br><span class="line">		...</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public class TimePrinter implements ActionListener{</span><br><span class="line">        @Override</span><br><span class="line">        public void actionPerformed(ActionEvent e) {</span><br><span class="line">            System.out.println("At the tone, the time is" + new Date());</span><br><span class="line">            if(beep){</span><br><span class="line">                Toolkit.getDefaultToolkit().beep();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们观察TimePrinter中的方法使用了beep变量，但是在TimePrinter类中没有实例域或者名为beep的变量，相反的是beep是引用的创建TimePrinter的TalkingClock对象的域，这是一种很创新的想法。</p>
<p>按传统意义来讲，一个方法可以引用调用这个方法的对象数据域。按照这样的思想，内部类既可以访问自身的数据域，也可以访问创建它的外部类对象的数据域。为了实现这一点，<strong>内部类的对象总有一个隐式引用，它指向了创建它的外部类对象</strong><br><img src="%E5%AF%B9%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E9%9A%90%E5%BC%8F%E5%BC%95%E7%94%A8.jpg" alt=""></p>
<p>这个引用在内部类的定义中是不可见的，外部类的引用是在构造器中设置。编译器修改了所有内部类的构造器，添加一个外部类引用的参数 ，因为TimePrinter类没有定义构造器，所以编译器为这个类生成了一个默认的构造器:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public TimePrinter(TalkingClock clock){</span><br><span class="line">	outer = clock;             //这里outer不是关键字，只是用来说明内部类中的机制</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当外部类对象创建了TimePrinter对象后，编译器就会将this引用传递给当前的TimePrinter构造器,<strong>通过这个隐式引用，我们可以访问外部类对象的数据域</strong>:</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ActionListener listener = new TimePrinter(this);</span><br></pre></td></tr></tbody></table></figure>

<div class="note default"><p>另外注意内部类只是一种编译器现象，与虚拟机无关。编译器会将内部类编译成 外部类名$内部类名 的常规文件，虚拟机对此一无所知。</p></div>

<h2 id="2-内部类可以对同一包中的其他类隐藏起来"><a href="#2-内部类可以对同一包中的其他类隐藏起来" class="headerlink" title="2.内部类可以对同一包中的其他类隐藏起来"></a>2.内部类可以对同一包中的其他类隐藏起来</h2><p>内部类和普通类有一个区别在于，普通类的修饰符不能是protected和private，<strong>而内部类的修饰符可以使用private和protected来修饰</strong>，这时候我们如果使用private来修饰内部类，那么这时内部类对外就被隐藏了。</p>
<p>内部类对外隐藏看似好像作用不大，其实在我们需要隐藏接口的实现的时候，内部类这一特性就起到了十分关键的作用。</p>
<p>那么我们为什么要隐藏接口的实现？隐藏接口的实现又有什么好处呢？</p>
<div class="note default"><p>我们隐藏接口的实现，就解决了继承以及实现接口后可能造成出现同名方法的问题</p></div>

<p>现在我们来看一个例子去更好的理解内部类对其他类隐藏起来了的好处：<br>一个接口Demo，中间有一个test()方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public interface Demo {</span><br><span class="line">    void test();      </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个类MyDemo,中间也有一个test()方法</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class MyDemo {</span><br><span class="line">  ​</span><br><span class="line">    public void test() {</span><br><span class="line">        System.out.println("父类的test方法");</span><br><span class="line">    }</span><br><span class="line">      </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个测试类</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class DemoTest extends MyDemo implements Demo {</span><br><span class="line">    public void test() {</span><br><span class="line">		</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们看测试类DemoTest继承了MyDemo，实现了Demo接口，而二者又都同时含有test方法，那么测试类DemoTest中的test()方法是覆写的谁的呢？这个时候我们就没法区分出这个方法是接口的还是继承的了，所以我们要使用内部类来解决这个问题：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class DemoTest extends MyDemo {</span><br><span class="line">  ​</span><br><span class="line">  ​</span><br><span class="line">    private class inner implements Demo {</span><br><span class="line">	    public void test() {</span><br><span class="line">		    System.out.println("接口的test方法");</span><br><span class="line">	    }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    public Demo getIn() {</span><br><span class="line">	    return new inner();</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">	    //调用接口而来的test()方法</span><br><span class="line">	    DemoTest dt = new DemoTest();</span><br><span class="line">	    Demo d = dt.getIn();</span><br><span class="line">	    d.test();</span><br><span class="line">	   </span><br><span class="line">	    //调用继承而来的test()方法</span><br><span class="line">	    dt.test();</span><br><span class="line">    }</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">接口的test方法</span><br><span class="line">父类的test方法</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以看到这时候因为同名造成的矛盾已经被解决了，在上面这段代码中，我们只知道DemoTest类中的getIn方法能返回一个Demo接口的实例，但是我们并不知道这个实例是怎么实现的，而且由于inner类是private的，所以如果我们不看源代码的话，我们根本就看不到这个具体类的名字，所以说他可以很好的实现隐藏</p>
<h2 id="3-内部类可以实现-java-单继承的缺陷"><a href="#3-内部类可以实现-java-单继承的缺陷" class="headerlink" title="3.内部类可以实现 java 单继承的缺陷"></a>3.内部类可以实现 java 单继承的缺陷</h2><p>我们都知道Java当中是只有单继承，没有多继承的，我们虽然可以使用实现多接口来解决没有多继承的问题，但是接口实现多了也会造成一些不方便的地方，比兔实现一个接口就必须实现它里面的所有方法，而我们使用内部类可以使我们的类继承多个具体的类或者抽象类，<strong>内部类的引入让我使得多继承的实现成为了可能</strong>，它使得我们从另外一个角度去实现了多继承</p>
<p>我们来看一下这个例子：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">//类一</span><br><span class="line">public class ClassA {</span><br><span class="line">   public String name(){</span><br><span class="line">       return "liutao";</span><br><span class="line">   }</span><br><span class="line">   public String doSomeThing(){</span><br><span class="line">    // doSomeThing</span><br><span class="line">   }</span><br><span class="line">}</span><br><span class="line">//类二</span><br><span class="line">public class ClassB {</span><br><span class="line">    public int age(){</span><br><span class="line">        return 25;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//类三</span><br><span class="line">public class MainExample{</span><br><span class="line">   private class Test1 extends ClassA{</span><br><span class="line">        public String name(){</span><br><span class="line">          return super.name();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    private class Test2 extends ClassB{</span><br><span class="line">       public int age(){</span><br><span class="line">         return super.age();</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">   public String name(){</span><br><span class="line">    return new Test1().name();</span><br><span class="line">   }</span><br><span class="line">   public int age(){</span><br><span class="line">       return new Test2().age();</span><br><span class="line">   }</span><br><span class="line">   public static void main(String args[]){</span><br><span class="line">       MainExample mi=new MainExample();</span><br><span class="line">       System.out.println("姓名:"+mi.name());</span><br><span class="line">       System.out.println("年龄:"+mi.age());</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以通过上面的例子看出来，MainExample类中的两个内部类分别继承了ClassA和ClassB，MainExample类通过这两个内部类间接实现了和ClassA还有ClassB的继承关系，而且我们也不用去关心ClassA的doSomeThing方法的实现，这是我们通过内部类实现多继承比实现接口更好的地方。</p>
<h2 id="4-当想要定义一个回调函数并且不想编写大量代码时，使用匿名内部类比较便捷"><a href="#4-当想要定义一个回调函数并且不想编写大量代码时，使用匿名内部类比较便捷" class="headerlink" title="4.当想要定义一个回调函数并且不想编写大量代码时，使用匿名内部类比较便捷"></a>4.当想要定义一个回调函数并且不想编写大量代码时，使用匿名内部类比较便捷</h2><p>我们用通俗讲解就是说在Java中，通常就是编写一个接口，然后你来实现这个接口，然后把这个接口的一个对象作以参数的形式传到另一个程序方法中， 然后通过接口调用你的方法，匿名内部类就可以很好的展现了这一种回调功能</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public interface Demo {</span><br><span class="line">    void demoMethod();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class MyDemo{</span><br><span class="line">    public test(Demo demo){</span><br><span class="line">	    System.out.println("test method");</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">	    MyDemo md = new MyDemo();</span><br><span class="line">	    //这里我们使用匿名内部类的方式将接口对象作为参数传递到test方法中去了</span><br><span class="line">	    md.test(new Demo){</span><br><span class="line">		    public void demoMethod(){</span><br><span class="line">		  	  System.out.println("具体实现接口")</span><br><span class="line">		    }</span><br><span class="line">	    }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h1 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h1><h2 id="1-局部内部类"><a href="#1-局部内部类" class="headerlink" title="1.局部内部类"></a>1.局部内部类</h2><div class="note default"><p>如果一个内部类只在一个方法中使用到了，那么我们可以将这个类定义在方法内部，这种内部类被称为局部内部类。其作用域仅限于该方法。</p></div>

<p>局部类有几点值得我们注意的地方：</p>
<div class="note default"><ol>
<li>局部内类不允许使用访问权限修饰符，public private protected 均不允许</li>
<li>局部内部类对外完全隐藏，除了创建这个类的方法可以访问它，其他的地方是不允许访问的。</li>
<li>局部内部类与成员内部类不同之处是他可以引用成员变量，但该成员必须声明为 final，并内部不允许修改该变量的值。（这句话并不准确，因为如果不是基本数据类型的时候，只是不允许修改引用指向的对象，而对象本身是可以被就修改的）</li>
</ol></div>

<p>局部类只能访问他所在的方法的final局部变量，如果我们访问了非final变量，编译器会提示你讲变量声明为final。局部变量的声明周期与局部内部类的对象的生命周期不一致。局部变量当所处的函数执行结束后就已经死亡了，但是局部内部类对象还可能一直存在(只要有人还引用该对象)，这就是会出现了一个悲剧的结果，局部内部类对象访问一个已经不存在的局部变量。那么编译器会将外部的final变量在编译阶段就作为内部类的成员变量写入内部类</p>
<p>原始类：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class S2 {</span><br><span class="line"> </span><br><span class="line">    public void outerDoSomething() {</span><br><span class="line">        final String localObj = "hello";</span><br><span class="line">        class InnerClass {</span><br><span class="line">            public void innerDoSomething() {</span><br><span class="line">                String a = localObj;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line"> </span><br><span class="line">        InnerClass innerObj = new InnerClass();</span><br><span class="line">        innerObj.innerDoSomething();</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        S2 s2 = new S2();</span><br><span class="line">        s2.outerDoSomething();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>编译之后的class文件：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class S2 {</span><br><span class="line">    public S2() {</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    public void outerDoSomething() {</span><br><span class="line">        String localObj = "hello";</span><br><span class="line">        class InnerClass {</span><br><span class="line">            InnerClass() {</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            public void innerDoSomething() {</span><br><span class="line">                String a = "hello";</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        InnerClass innerObj = new InnerClass();</span><br><span class="line">        innerObj.innerDoSomething();</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        S2 s2 = new S2();</span><br><span class="line">        s2.outerDoSomething();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>所以访问外部的final变量，在编译器就放入内部类了，与外部无关。所以访问安全。</p>
<h2 id="2-成员内部类"><a href="#2-成员内部类" class="headerlink" title="2.成员内部类"></a>2.成员内部类</h2><div class="note default"><p>成员内部类就是最普通的内部类，它定义在一个类的内部中，就如同一个成员变量一样。</p></div>

<ul>
<li>在内部类中，直接使用变量名，会按照从方法中的局部变量、到局部类的变量、到外部类的变量的顺序访问(就近原则)</li>
<li>如果想在方法中强制访问内部类的成员变量/方法，可以使用<span class="label default">this.变量名</span>，这里的this表示当前内部类对象</li>
<li>如果想在方法中强制访问外部类的成员变量/方法，可以使用<span class="label default">外部类名.this.变量名</span>，这里的<span class="label default">外部类名.this</span>表示当前外部类对象</li>
</ul>
<p>成员内部类和外部类的成员一样，可以使用4种权限修饰符来修饰，但是有一个限制：<strong>成员内部类不能创建静态变量/方法</strong></p>
<p>那为什么会这样呢？</p>
<div class="note default"><p>因为要使用一个类的静态成员，需要先把这个类加载到虚拟机中，而成员内部类是需要由外部类对象 new 一个实例才可以使用，这就无法做到静态成员的要求。</p></div>


<h2 id="3-匿名内部类"><a href="#3-匿名内部类" class="headerlink" title="3.匿名内部类"></a>3.匿名内部类</h2><p>我们先来看一段最常见的代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Car jeep = new Car();</span><br></pre></td></tr></tbody></table></figure>

<p>在Java中，可以将jeep抽象的理解为Car对象的”名字”，而匿名内部类顾名思义可以抽象的理解为没有名字的”内部类”</p>
<p>匿名内部类的特点：</p>
<div class="note default"><ol>
<li>一个类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的事先或是覆盖。</li>
<li>类名没有意义，也就是不需要使用到。</li>
<li>匿名内部类是没有访问修饰符的。</li>
<li>匿名内部类中不能存在任何静态成员或方法</li>
<li>匿名内部类是没有构造方法的，因为它没有类名。</li>
<li>与局部内部相同匿名内部类也可以引用局部变量。此变量也必须声明为 final</li>
<li>匿名内部类是没有构造方法的，因为它没有类名</li>
</ol></div>

<p>现在我们来看一个匿名内部类：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class Button {</span><br><span class="line">    public void click(final int params){</span><br><span class="line">        //匿名内部类，实现的是ActionListener接口</span><br><span class="line">        new ActionListener(){</span><br><span class="line">            public void onAction(){</span><br><span class="line">                System.out.println("click action..." + params);</span><br><span class="line">            }</span><br><span class="line">        }.onAction();</span><br><span class="line">    }</span><br><span class="line">    //匿名内部类必须继承或实现一个已有的接口</span><br><span class="line">    public interface ActionListener{</span><br><span class="line">        public void onAction();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Button button=new Button();</span><br><span class="line">        button.click();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>匿名内部类在开发中的使用：</p>
<p>我们在开发的时候，会看到抽象类，或者接口作为参数。而这个时候，实际需要的是一个子类对象。如果该方法仅仅调用一次，我们就可以使用匿名内部类的格式简化。</p>
<h2 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h2><p>对于一般的类，我们知道是不能使用static来修饰的，但是成员内部类可以看做外部类中的一个成员，所以可以用static修饰，这种用static修饰的内部类我们称作静态内部类,也称作嵌套内部类.</p>
<p>特点：<br>    - 不能使用外部类的非static成员变量和成员方法，只能访问静态的外部属性和方法<br>    - 非静态内部类编译后会默认的保存一个指向外部类的引用，而静态类却没有</p>
<p>一个静态内部类    </p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">class Outter {</span><br><span class="line">    int age = 10;</span><br><span class="line">    static age2 = 20;</span><br><span class="line">    public Outter() {        </span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    static class Inner {</span><br><span class="line">        public method() {</span><br><span class="line">            System.out.println(age);//错误</span><br><span class="line">            System.out.println(age2);//正确</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">  ​</span><br><span class="line">public class Test {</span><br><span class="line">    public static void main(String[] args)  {</span><br><span class="line">        Outter.Inner inner = new Outter.Inner();</span><br><span class="line">        inner.method();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么Java中只有值传递</title>
    <url>/2019/10/25/%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%AD%E5%8F%AA%E6%9C%89%E5%80%BC%E4%BC%A0%E9%80%92/</url>
    <content><![CDATA[<h1 id="JAVA中的参数传递"><a href="#JAVA中的参数传递" class="headerlink" title="JAVA中的参数传递"></a>JAVA中的参数传递</h1><p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span>&nbsp;&nbsp;&nbsp;在JAVA的学习中，我们或许经常性的会遇到把对象作为一个参数传递给方法，那么自然就会产生一个问题，这到底是值传递，还是引用传递呢？<br><br>或许很多人都会觉得是引用传递，但其实我们都错了！</p>
<a id="more"></a>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span>答案是：<strong>对象作为参数传递是值传递，并且在JAVA中，<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8">❗</span>只有按值传递，没有按引用传递！</strong></p>
<hr>
<p>我们在解释为什么之前，先来看看<strong>形参</strong>是什么，<strong>实参</strong>是什么，什么是<strong>值传递</strong>，什么又是<strong>引用传递</strong></p>
<p><strong>形参：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。</strong></p>
<p><strong>实参：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。</strong></p>
<p><strong>值传递（pass by value）：在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</strong></p>
<p><strong>引用传递（pass by reference）：在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</strong></p>
<hr>
<p>在弄清楚了这些概念之后，我们现在通过代码实践的方式，来看看JAVA中到底为什么是值传递<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8">❓</span></p>
<p>首先我们来看这样一段代码：<br><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8">1⃣</span></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class Test {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        int i = 1;</span><br><span class="line">        test.change(i);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void change(int i){</span><br><span class="line">        i = 2;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></tbody></table></figure>

<p>从这个运行结果来看，change方法内改变i的值并没有影响到mian方法中的i，由此来看应该是值传递，那我们在来看一段实例代码<br></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8">2⃣</span></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class Test {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName("first");</span><br><span class="line">        test.change(user);</span><br><span class="line">        System.out.println("main方法内的name：" + user.name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">        public void change(User user){</span><br><span class="line">        user.setName("second");</span><br><span class="line">        System.out.println("change方法内的name："+user.name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这是运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">change方法内的name：second</span><br><span class="line">main方法内的name：second</span><br></pre></td></tr></tbody></table></figure>
<p>从这样的结果来看，在change方法体内对user对象进行的操作也已经改变了main方法体内的user对象，那么就此结果来说JAVA看上去又像是可以引用传递的，但是这里有一段代码却提出了疑问<br></p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/0033-20e3.png?v8">3⃣</span></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class Test {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Test test = new Test();</span><br><span class="line">        String name = "first";</span><br><span class="line">        test.change(name);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void change(String name){</span><br><span class="line">        name = "second";</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">second</span><br><span class="line">first</span><br></pre></td></tr></tbody></table></figure>
<p>这样的运行结果，让我们看起来JAVA又是值传递，那么我们到底该作何解释呢？</p>
<h4 id="JAVA中的值传递"><a href="#JAVA中的值传递" class="headerlink" title="JAVA中的值传递"></a>JAVA中的值传递</h4><table>
<thead>
<tr>
<th>&nbsp;&nbsp;</th>
<th align="center">值传递</th>
<th align="right">引用传递</th>
</tr>
</thead>
<tbody><tr>
<td>根本区别</td>
<td align="center">会创建副本(Copy)</td>
<td align="right">不创建副本</td>
</tr>
<tr>
<td>所以</td>
<td align="center">函数无法改变原始对象</td>
<td align="right">函数可以改变原始对象</td>
</tr>
</tbody></table>
<p>我们在上面的几个例子之中，都只是关注了传参之后实参内容是否有所改变，但其实我们从一开始得到观察方法上就错了，我们要看的应该是它如何造成这样的结果的，而不是只看结果来得出结论，这样得出的结论当然是错误的。</p>
<p>关于值传递和引用传递我们可以举一个生活中实际的例子来看：</p>
<p>&nbsp;&nbsp;&nbsp;我们现在有一把钥匙，当我们的朋友想去我们家里时，我们直接把我们的钥匙给他，这就是<strong>引用传递</strong>，在这种情况下，如果他对这把钥匙做了什么事，比如说刻下了自己的名字，那么这把钥匙归还给你的时候，钥匙上也会多出他刻下的名字</p>
<p><img src="2.png" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;我们现在有一把钥匙，当我们的朋友想去我们家里时，我们复制一把备用钥匙给他，自己的钥匙还是在自己手里，这就是<strong>值传递</strong>，这种情况下，他对他那把钥匙做什么，都不会影响到你手里的钥匙</p>
<p><img src="3.png" alt=""></p>
<p>&nbsp;&nbsp;&nbsp;但是，上面的两种情况，你朋友拿着你的钥匙进入到家里，把你的电脑弄坏了，你同样是会受到影响的，哦们在change方法中，改变user对象的name属性时，不正是在“弄坏电脑吗”，我们改变的不是那把钥匙，而是钥匙打开的房子。</p>
<hr>
<p>当我们在main中<strong>new User()对象</strong>的时候，在堆中开辟一块内存，其中保存了name等数据。然后<strong>main中的user</strong>持有该内存的地址0x123456 。</p>
<p>当尝试调用<strong>change</strong>方法，并且<strong>main中的user</strong>作为<strong>实际参数</strong>传递给<strong>形式参数user</strong>的时候，会把这个地址0x123456 交给<strong>change中的user</strong>，这时，<strong>change中的user</strong>也指向了这个地址。</p>
<p>然后在<strong>change方法内对参数user</strong>进行修改的时候，<strong>即user = new User();</strong> ，会重新开辟一块0X456789 的内存，赋值给<strong>change中的user</strong>。后面对<strong>change中的user（即内存0X456789）</strong>的任何修改都不会改变<strong>main中user(即内存0X123456)的内容</strong>。</p>
<p><img src="4.png" alt=""></p>
<p>上面这种传递是什么传递？肯定不是引用传递，如果是引用传递的话，在执行user = new User();的时候，实际参数的引用也应该改为指向 0X456789，但是实际上并没有。</p>
<p>通过概念我们也能知道，这里是把实际参数的引用的地址复制了一份，传递给了形式参数。所以，上面的参数其实是值传递，把实参对象引用的地址当做值传递给了形式参数。</p>
<p><img src="5.png" alt=""></p>
<p>在第二段代码中，在change方法内user指向的地址没有发生改变，所以它的修改对main方法内的user产生了影响，在第三段代码中，name指向的内存地址已经发生了改变，所以不管change方法内怎么变化，不会影响到main方法中的name</p>
<p><strong>所以，值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。</strong>在判断实参内容有没有受影响的时候，要看传的的是什么，如果你传递的是个地址，那么就看这个地址的变化会不会有影响，而不是看地址指向的对象的变化。就像钥匙和房子的关系。</p>
<p><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f3c1.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f3c1.png?v8">🏁</span><strong>所以说，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象地址的引用。</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈基本类型与包装类型的区别</title>
    <url>/2019/10/24/%E6%B5%85%E8%B0%88%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>在Java中每个基本类型都对应了一个包装类型，他们之间可以通过自动装箱和自动拆箱自由的转化，但是他们之间是不同的，两者之间的差别在使用的时候可能会造成很严重的错误，所以我们在使用的时候要特别注意。他们之间主要区别以及注意事项有以下几点</p>
<h2 id="包装类型值可以为NULL，但是基本类型不可以"><a href="#包装类型值可以为NULL，但是基本类型不可以" class="headerlink" title="包装类型值可以为NULL，但是基本类型不可以"></a>包装类型值可以为NULL，但是基本类型不可以</h2><p>因为包装类型可以为NULL这一特点，使得包装类型可以应用于POJO类中，但是基本类型不可以。</p>
<p>这里POJO的全称为<span class="label default">Plain Ordinary Java</span>,也就是无规则的Java对象，只有属性字段以及相应的setter和getter方法，比如：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public class User {</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public Integer getId() {</span><br><span class="line">        return id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) {</span><br><span class="line">        this.id = id;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getName() {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>与POJO相类似的还有数据传输对象DTO(Data Transfer Object，泛指用于展示层与服务层之间的数据传输对象)、视图对象VO(View Object，把某个页面的数据封装起来)、持久化对象PO(Persistant Object,可以看成是与数据库中的表映射的Java对象)</p>
<p>包装数据类型的默认初始值是null，而基本数据类型的默认初始值则不是，比如int初始值为0，double初始值为0.0，等等，在数据库中，所有SQL默认值都是null，如果我们把POJO中的映射属性类型写为基本类型，当查找不到记录的时候，返回null赋给基本类型就会出错，这个时候我们只有使用包装类型才能保证不会出现这样的错误</p>
<p>在《阿里巴巴的Java开发手册中》有这样的说明</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">数据库的查询结果可能是null，如果使用基本类型的话，因为要自动拆箱(将包装类型转化为基本类型，比如说把Integer对象转化为int值)，</span><br><span class="line"></span><br><span class="line">就会抛出NPE(NullPointerException)的异常</span><br></pre></td></tr></tbody></table></figure>

<p>所以在阿里巴巴的Java开发手册中强制规定了基本数据类型和包装数据类型的使用标准如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">（1） 所有的POJO类属性必须使用包装数据类型。</span><br><span class="line"></span><br><span class="line">（2） RPC方法的返回值和参数必须使用包装数据类型。</span><br><span class="line"></span><br><span class="line">（3） 所有的局部变量推荐使用基本数据类型。</span><br></pre></td></tr></tbody></table></figure>

<h2 id="包装类型可以用在泛型之中，但是基本类型不可以"><a href="#包装类型可以用在泛型之中，但是基本类型不可以" class="headerlink" title="包装类型可以用在泛型之中，但是基本类型不可以"></a>包装类型可以用在泛型之中，但是基本类型不可以</h2><p>泛型不能使用基本类型，如果使用了基本类型，那么在编译的时候将会报错</p>
<p>错误写法：</p>
<div class="note danger"><p>List<int> list = new ArrayList&lt;&gt;();</int></p></div>

<p>正确写法：</p>
<div class="note default"><p>List<integer> list = new ArrayList&lt;&gt;();</integer></p></div>

<p>造成这种结果的原因是因为泛型在编译时会进行类型擦除，最后只保留原始类型，而原始类型只能是Object及其子类。</p>
<h2 id="基本类型相较于包装类型更加的高效"><a href="#基本类型相较于包装类型更加的高效" class="headerlink" title="基本类型相较于包装类型更加的高效"></a>基本类型相较于包装类型更加的高效</h2><p>基本类型相较于包装类型更加的高效，因为基本类型在栈中直接储存的具体数值，而包装类型则在栈中储存的是对堆中的引用(即在堆中的地址)</p>
<p><img src="stack_and_heap.jpg" alt=""></p>
<p>很显然，包装类型在堆中还要占用内存，它需要占据更多的内存空间，对于我们经常要用到的局部变量来说，每次如果都要new一个包装类型就会显得十分的笨重，所以在阿里巴巴Java开发手册中，对于局部变量更加推荐使用基本数据类型</p>
<h2 id="两个包装类型的值可以相同，但是却不相等"><a href="#两个包装类型的值可以相同，但是却不相等" class="headerlink" title="两个包装类型的值可以相同，但是却不相等"></a>两个包装类型的值可以相同，但是却不相等</h2><p>首先我们来看一段代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Integer a = new Integer(10);</span><br><span class="line">Integer b = new Integer(10);</span><br><span class="line"></span><br><span class="line">System.out.println(a == b);   //输出为false</span><br><span class="line">System.out.println(a.equals(b));    //输出为true</span><br></pre></td></tr></tbody></table></figure>

<p>使用“==”的时候，我们比较的是栈内存中的内容，所以对于类对象，使用“==”比较的是他们在内存中指向的地址是否相同，而对于基本数据类型，使用“==”则比较的是他们的值是否相同，所以第一个结果是false</p>
<p>使用equals函数进行比较则比较的是他们的值，所以第二个结果是ture</p>
<p>综上所述我们在进行包装类的比较时，如果使用“==”那么结果可能会出人意料</p>
<h2 id="自动装箱与自动拆箱"><a href="#自动装箱与自动拆箱" class="headerlink" title="自动装箱与自动拆箱"></a>自动装箱与自动拆箱</h2><p>首先来谈谈两个的概念：<br>自动装箱：将基本类型转换为包装类型<br>自动拆箱：将包装类型转换为基本类型</p>
<p>在JavaSE5之前，我们是要手动拆装箱的:</p>
<div class="note default"><p>Integer integer = new Integer(10); //手动装箱<br>int i = integer.intValue();        //手动拆箱</p></div>

<p>但是在JavaSE5之后，就提供了自动拆装箱的功能:</p>
<div class="note default"><p>Integer integer  = 10;  // 自动装箱<br>int i = integer;        // 自动拆箱</p></div>

<p>自动拆装箱反编译之后：</p>
<div class="note default"><p>Integer integer = Integer.valueOf(10);<br>int i = integer.intValue();</p></div>

<p>现在我们来看三段代码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">// 基本类型和包装类型的比较</span><br><span class="line">int a = 100;</span><br><span class="line">Integer b = 100;</span><br><span class="line">System.out.println(a == b);</span><br><span class="line"></span><br><span class="line">// 两个包装类型的比较</span><br><span class="line">Integer c = 100;              //这里和第四点不一样的赋值不一样哦</span><br><span class="line">Integer d = 100;</span><br><span class="line">System.out.println(c == d);</span><br><span class="line"></span><br><span class="line">// 两个基本类型的比较</span><br><span class="line">c = 200;</span><br><span class="line">d = 200;</span><br><span class="line">System.out.println(c == d);</span><br></pre></td></tr></tbody></table></figure>

<p>第一段：<strong>基本类型</strong>和<strong>包装类型</strong>的比较</p>
<div class="note primary"><p>结果：true</p></div>

<p>第二段：<strong>包装类型</strong>与<strong>包装类型</strong>之间的比较(<strong>对包装类型直接赋值，不是使用new Integer()</strong>)</p>
<div class="note primary"><p>结果：true</p></div>

<p>第三段：<strong>包装类型</strong>和<strong>包装类型</strong>之间进行比较(<strong>重新赋值200之后</strong>)</p>
<div class="note primary"><p>结果：false</p></div>

<p>这三次比较的结果是true，true，false，可能你会有点意外，现在我们来看看这是为什么？</p>
<p>通过前面我们观察自动拆装箱的反编译结果，我们可以知道，自动装箱是通过<span class="label default">Integer.valueOf</span>完成的，那我们就来看看这个方法的源码</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">public static Integer valueOf(int i) {</span><br><span class="line">    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        return IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    return new Integer(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从这个方法的源码中我们可以明显的看到IntegerCache起到了很重要的作用，那这个时候我们又来看看IntegerCache是什么：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">private static class IntegerCache {</span><br><span class="line">    static final int low = -128;</span><br><span class="line">    static final int high;</span><br><span class="line">    static final Integer cache[];</span><br><span class="line"></span><br><span class="line">    static {</span><br><span class="line">        // high value may be configured by property</span><br><span class="line">        int h = 127;</span><br><span class="line">        int i = parseInt(integerCacheHighPropValue);</span><br><span class="line">        i = Math.max(i, 127);</span><br><span class="line">        h = Math.min(i, Integer.MAX_VALUE - (-low) -1);</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = new Integer[(high - low) + 1];</span><br><span class="line">        int j = low;</span><br><span class="line">        for(int k = 0; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = new Integer(j++);</span><br><span class="line"></span><br><span class="line">        // range [-128, 127] must be interned (JLS7 5.1.7)</span><br><span class="line">        assert IntegerCache.high &gt;= 127;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>从这段代码中我们可以看出-128到127之间的数会从IntegerCache中取值，<strong>即对于-128到127之间的数，会进行缓存，例如Integer i = 127时，会将127进行缓存，下次在写Integer j = 127的时候，就会直接从缓存中取，就不会new了，如果超过128就会重新new一个对象</strong></p>
<div class="note default"><p>所以在我们这个问题中:</p>
<p>第一段是因为，当包装类型和基本类型进行比较时，会进行自动拆箱，是二者的值进行的比较，所以结果是true，</p>
<p>第二段是因为，100是在-128到127之间，d指向的是缓存中的对象，和c指向的是同一个对象，所以结果是true</p>
<p>第三段是因为，200超过了127，c和d都是重新new Integer(200)，且是不同的对象，所以结果是false</p></div>

<p>看完了这么多，提炼一下，在这种会进行自动拆装箱的问题中，我们需要注意的是：</p>
<blockquote class="blockquote-center"><p>当需要进行自动装箱的时候，如果数字在-128到127之间，会直接使用缓存中的对象，而不是重新创建一个对象，如果数字大于或者小于这两个，那么是会重新创建一个对象的</p>
</blockquote>

<p>Ps:<br><br>本文参考自：<a href="https://juejin.im/post/5d8ff563f265da5bb252de76" target="_blank" rel="noopener">https://juejin.im/post/5d8ff563f265da5bb252de76</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础类型</tag>
        <tag>包装类型</tag>
      </tags>
  </entry>
</search>
